#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2012-2016, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# Look up names in a Gedcom file on findagrave, billiongraves, gravestonephotos,
# canadianheadstones, tombfinder and the Commonwealth War Graves Commission

# -F: only search findagrave and only search those we don't already have

# As the size of these databases increases, one can expect more matches. Do
# your part to help - sign up to billiongraves.com and start uploading pictures.

# There will be plenty of false matches - expect that. Personally I'd be happy
# with 75% being false matches if it meant I got new information - Genealogy
# is all about false leads!

# Often data doesn't include the country of death. When that happens I have
# three choices:
# 1) Ignore that record (I think that would miss too many people)
# 2) Search for that person in all countries (I think that would return too
#	many wrong matches)
# 3) Make an educated guess on the country.
# I've gone for option 3. That's going to give me a lot of work, but I think
# will be the best in the long run. Don't expect it to be right yet, so for now
# expect records to be missed when the country isn't given.

# Set ANSI_COLORS_DISABLED=1 to disable coloured output - useful when
#	redirecting the output to a file

# TODO: Added the list of sites on the Open Gravestones Research papper
# TODO: If no match, try the firstname as an initial
# TODO: Optimise each driver to minimise impact on the websites
# TODO: ozburials.com
# TODO: http://canadianheadstones.com/other_index.htm (Ireland)
# TODO: teafor2.com/mycemeteries.com
# TODO: http://www.all-genealogysites.com/Cemeteries/
# TODO: Handle alternative names
# FIXME: CWGC commission code doesn't work
# FIXME: billiongraves keeps changing
# FIXME: tombfinder doesn't return exact matches, so you will
#	get incorrect matches - but that's preferable to missing some
# FIXME: Handle multiple pages (findagrave has been done)
# FIXME: only looks at one husband's surname - won't work if
#	a woman was married more than once
# FIXME: If death country is UK, only searches in England
# FIXME: Expect too many matches on records without a country and csp of death
# FIXME: Tombfinder sometimes gives 500 errors
# TODO: gravestonephotos.com gives a lot of false positives
# FIXME: It's slow.
# TODO: Add more intelligence to the location parser, if the location is
#	"Margate, Kent", we should infer the country as "England".
# TODO: Ignore anyone with the living tag if set, it's quicker
# TODO: Use LWP::ConsoleLogger for debugging when uber verbose is set
# FIXME: Rewrite the freereg driver to use the new interface

use strict;
use warnings;
use autodie qw(:all);
# use diagnostics;
use feature 'state';

# use Coro::LWP;
# use Coro;
# use Coro::EV;
use Parallel::Simple qw(prun);	# FIXME: Doesn't work on Windows
use Getopt::Std;
use Encode;
use Gedcom;
use WWW::Mechanize::GZip;
use HTML::SimpleLinkExtor;
# use XML::LibXML;
# use LWP;
use CHI;
use Locale::Object::Country;
use Locale::US;
use Locale::CA;
use Locale::SubCountry;
use Memoize;
use HTTP::Cookies;
# use warnings::unused;
# use Warn::Colorful(base => 'red', body => 'red', line => 'red');
use Term::ANSIColor;
use DateTime::Format::Natural;
use Date::Calc;
use File::Spec;

my %opts;

getopts('c:dfFn:s:mvx', \%opts);

if($opts{m}) {	# list module dependencies
	print "List of dependencies you need to install from CPAN:\n";
	print join("\n", map { s|/|::|g; s|\.pm$||; $_ } keys %INC);
	print "\n";
	exit;
}
die "Usage: $0 [ -c default-country-of-death ] [ -d ] [ -f ] [ -F ] [ -m ] [ -n lastname ] [ -s default-subcountry-of-death ] [ -v ] [ -x ] filename\n" unless($ARGV[0]);

my $default_country = $opts{c};
my $default_subcountry = $opts{s};
my $verbose = $opts{v};
my $debug = $opts{d};
my $excel = $opts{x};
my $freereg_only = $opts{f};
my $new_findagrave_only = $opts{'F'};
my $surname_to_match;
my $parallel = ($^O eq 'MSWin32') ? 0 : 1;
$parallel = 0;

if($debug) {
	$verbose++;
}

if($opts{n}) {
	$surname_to_match = lc($opts{n});
}

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
my $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache');
my $lwpcache;

# Not when running in Parallel - you get HTML::Form errors
# because HTTP::Cache::Transparent is not thread safe.
if($parallel) {
	require LWPx::UserAgent::Cached;
	LWPx::UserAgent::Cached->import();

	$lwpcache = CHI->new(driver => 'File', root_dir => $cachedir, expires_in => '1 month', namespace => 'LWPx::UserAgent::Cache');
} else {
	require HTTP::Cache::Transparent;
	HTTP::Cache::Transparent->import();

	HTTP::Cache::Transparent::init( {
	BasePath => "$cachedir/http-cache-transparent",
	# Verbose => 1,
	NoUpdate => 60 * 60,
	MaxAge => 15 * 24} ) || die "$0/cache: $!";
}

# Gedcoms exported by ancestry.co.uk fail this...
# die "Invalid gedcom file $ARGV[0]\n" unless($ged->validate());

memoize('check_country');

# Set of caches for each driver
my $tcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'tombfinder', expires_in => '1 day');
my $bcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'billiongraves', expires_in => '1 day');
my $fcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'findagrave', expires_in => '1 day');
my $gcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'gravestonephotos', expires_in => '1 day');
my $gcache2 = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'gravestonephotos2', expires_in => '1 day');
my $gcache3 = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'gravestonephotos3', expires_in => '1 day');
my $hcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'headstones', expires_in => '1 day');
my $hcache2 = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'headstones2', expires_in => '1 day');
my $tf2cache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'teafor2', expires_in => '1 day');
my $tf2cache2 = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'teafor2', expires_in => '1 day');
my $vcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'virtualcemetery', expires_in => '1 day');
my $ccache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'commonwealth', expires_in => '1 day');
my $freeregcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'freereg', expires_in => '1 day');
# my $rcache = CHI->new(driver => 'File', root_dir => $cachedir, namespace => 'restingspot', expires_in => '1 day');

# Set of WWW::Mechanize::GZip objects for each driver
my $tmech = WWW::Mechanize::GZip->new();
my $bmech = WWW::Mechanize::GZip->new();
my $fmech = WWW::Mechanize::GZip->new();
my $gmech = WWW::Mechanize::GZip->new();
my $hmech = WWW::Mechanize::GZip->new();
my $tf2mech = WWW::Mechanize::GZip->new();
my $freeregmech = WWW::Mechanize::GZip->new();
# my $rmech = WWW::Mechanize::GZip->new();

# This is needed because if you're outside the US, genealogy.com unhelpfully
# redirects you to ancestry :-(
my $vjar = HTTP::Cookies->new();
$vjar->set_cookie(qw(
	3
	IPCheck
	1
	/
	.genealogy.com
	0
	0
	0
	)
);
my $vmech = WWW::Mechanize::GZip->new(cookie_jar => $vjar);
my $cmech = WWW::Mechanize::GZip->new();

PERSON: foreach my $person($ged->individuals()) {
	# Gather the information on this person
	my $name = $person->name();

	# print "$name\n";
	if($name =~ /(.+?)\s*[SJ]r\.?/i) {
		$name = $1;
	}
	if($name =~ /(.+)Mc\s+(.+)/) {
		$name = "$1$2";
	}
	$name =~ s/[\(\)]//g;

	next unless($name =~ /^(.+)\s+\/(.+)\/(.*)/);

	my ($firstname, $middlename, $lastname, $suffix);
	$firstname = lc($1);
	$lastname = lc($2);
	$suffix = $3;

	next unless($firstname && $lastname);

	if($firstname =~ /(.+)?\s+(.+)/) {
		$firstname = $1;
		unless($2 eq $lastname) {
			$middlename = $2;
		}
	}

	$suffix =~ s/^\s+//;

	my $dob;
	eval {
		$dob = $person->get_value('birth date');
	};
	if($@) {
		warn "Can't parse record for $firstname $lastname";
		next;
	}

	my $dod = $person->get_value('death date') ? $person->get_value('death date') : $person->get_value('burial date');

	if($dod && ($dod =~ /.*?(\d{3,4})/)) {
		$dod = $1;
	}

	unless($dob) {
		$dob = $person->get_value('baptism date');
	}

	if($dob && ($dob =~ /.*?(\d{3,4})/)) {
		$dob = $1;
	} elsif($dob) {
		print colored($person->name() . ": invalid date of birth $dob", 'yellow'), "\n";
		$dob = undef;
	}

	if((!defined($dod)) && defined($dob) && ($dob > 1900)) {
		# Assuming living if we don't have a date of death and
		# they were born after 1900
		next;
	}

	if($new_findagrave_only) {
		my $burial = $person->get_record('burial');
		my $placeofburial = $person->get_value('burial place');
		if((!$placeofburial) && $burial) {
			$placeofburial = $burial->place();
		}
		if($placeofburial) {
			my @s = $burial->source();
			foreach my $src(@s) {
				$src = $ged->get_source($src) unless ref($src);
				if($src->title() && ($src->title() =~ /find a grave/i)) {
					next PERSON;
				}
			}
		}
	}

	my $dcountry = $person->get_value('death place');

	unless($dcountry) {
		# Assume that the person died in the same country that
		# they were born in.  Not that many people emigrate who
		# don't have recorded information
		$dcountry = $person->get_value('birth place');
		print colored($person->name() . ': unknown place of death trying place of birth', 'yellow'), "\n" if($debug);
	}
	# Parse the death location, trying to extract as much information as
	# possible
	if($dcountry) {
		$dcountry =~ s/[\s,]*$//;
		$dcountry =~ s/,\s+,/,/g;
		$dcountry =~ s/^[\s,]*//;
	}
	my $dcsp;
	if($dcountry && ($dcountry =~ /(.*[,-])\s*(.+)/)) {
		$dcsp = $1;
		$dcountry = $2;
		if($dcsp && ($dcsp =~ /.*[,-]\s*(.+)/)) {
			$dcsp = $1;
			$dcsp =~ s/^\s*//;
		}
	}

	if(defined($dcsp)) {
		$dcsp =~ s/[,;.\)]//g;
	}

	if(defined($dcountry)) {
		my $d = $dcountry;
		$d =~ s/\s+$//;
		if($d =~ /(.+?)\.\s/) {
			unless($1 eq 'Co') {
				$d = $1;
			}
		}
		$d =~ s/\)//g;
		$d =~ s/[;\.]\s*/ /;
		$d =~ s/^\W+//;	# Remove leading other characters
		if($debug) {
			print "$firstname $lastname: ",
				$person->get_value('death place'), '; ';
			if($dcsp) {
				print "csp=>$dcsp, country => '$d' ";
			} else {
				print "country => '$d' ";
			}
		}
		my ($new_country, $csp) = check_country({
			csp => $dcsp,
			country => $d,
			default_country => $default_country,
		});
		if($debug) {
			if($csp) {
				print "after csp=>$csp, country => $new_country\n";
			} elsif($new_country) {
				print "after country => $new_country\n";
			} else {
				print "after country => <<undef>>\n";
			}
		}
		if(defined($new_country)) {
			$d = $new_country;
		} else {
			if(defined($default_country) && ($default_country =~ /United States/i)) {
				# There may be a state in there somewhere
				$d = $person->get_value('death place');
				if($d =~ /,\s*([A-Z]{2})/) {
					$d = 'United States';
					$dcsp = us_state($1);
				}
			}
			unless($d) {
				print colored($person->name() . ": unknown country $dcountry", 'yellow'), "\n";
				$d = undef;
			}
		}
		$dcountry = $d;
		$dcsp = $csp;
	}

	if($dcsp && $dcountry && ($dcsp eq $dcountry)) {
		$dcsp = undef;
	}
	# If all else fails, try to extract the CSP as the next to last field in the death place
	if((!defined($dcsp)) && defined($dcountry)) {
		my $d = $person->get_value('death place') || $person->get_value('birth place');
		if($d =~ /[\s\w,\.]*,\s?(.+),\s*\Q$dcountry\E/i) {
			$dcsp = $1;
			$dcsp =~ s/^\s*//;
			if($dcsp eq '') {
				$dcsp = undef;
			}
		}
	}

	if((!defined($dcountry)) && defined($default_country)) {
		$default_country = lc($default_country);
		$dcountry = ucfirst($default_country);
		if((!defined($dcsp)) && defined($default_subcountry)) {
			$default_subcountry = lc($default_subcountry);
			$dcsp = ucfirst($default_subcountry);
		}
	}

	# Change surname of a married woman
	my $sex = $person->get_value('sex');
	my $maidenname;
	if(defined($sex) && ($sex eq 'F')) {
		my $husband = $person->husband();
		if(defined($husband)) {
			my $hname = $husband->name();
			if($hname =~ /(.+?)\s*[SJ]r\.?/i) {
				$hname = $1;
			}
			if($hname =~ /(.+)Mc\s+(.+)/) {
				$hname = "$1$2";
			}
			# print $person->name(), " married to $hname\n";
			if($hname =~ /^.+\s+\/(.+)\/$/) {
				$maidenname = $lastname;
				$lastname = lc($1);
			}
		}
	}

	# Remove alternatives - go with the first
	# TODO: try both alternatives
	if($lastname =~ /(.+)[\/\\]/) {
		$lastname = $1;
	}

	if(defined($surname_to_match)) {
		next unless($lastname eq $surname_to_match);
	}

	if($firstname =~ /(.+)[\/\\]/) {
		$firstname = $1;
	}

	my %params = (
		dob => $dob,
		dod => $dod,
		dcountry => $dcountry,
		dcsp => $dcsp,
		firstname => $firstname,
		middlename => $middlename,
		lastname => $lastname,
		maidenname => $maidenname,
		suffix => $suffix,
	);

	my $str = stringify(\%params);

	my $entry;

	if($freereg_only) {
		$entry = $freeregcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my $fparams = \%params;
			$fparams->{cache} = $freeregcache;
			$fparams->{mech} = $freeregmech;
			freereg($fparams);
		}
	} elsif($new_findagrave_only) {
		$entry = $fcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my $fparams = \%params;
			$fparams->{cache} = $fcache;
			$fparams->{mech} = $fmech;
			findagrave($fparams);
		}
	} elsif($parallel) {
		# Submit this person to each driver - one driver per site
		my @plist = ();
		if((!defined($dcountry)) || ($dcountry eq 'United States')) {
			$entry = $tcache->get($str);
			if((!defined($entry)) || ($entry > 0)) {
				my %tparams = %params;
				$tparams{cache} = $tcache;
				$tparams{mech} = $tmech;
				push @plist, tombfinder => [ \&tombfinder, \%tparams ];
			}
		} elsif(defined($dcountry) && ($dcountry eq 'Canada')) {
			$entry = $hcache->get($str);
			if((!defined($entry)) || ($entry > 0)) {
				my %cparams = %params;
				$cparams{cache} = $hcache;
				$cparams{cache2} = $hcache2;
				$cparams{mech} = $hmech;
				push @plist, canadianheadstones => [ \&canadianheadstones, \%cparams ];
			}
		}

		# Cybersquatted
		# if(defined($dcountry) && ($dcountry eq 'United States')) {
			# $entry = $hcache->get($str);
			# if((!defined($entry)) || ($entry > 0)) {
				# my %hparams = %params;
				# $hparams{cache} = $hcache;
				# $hparams{cache2} = $hcache2;
				# $hparams{mech} = $hmech;
				# push @plist, americanheadstones => [ \&americanheadstones, \%hparams ];
			# }
		# }

		$entry = $fcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %fparams = %params;
			$fparams{cache} = $fcache;
			$fparams{mech} = $fmech;
			push @plist, findagrave => [ \&findagrave, \%fparams ];
		}

		$entry = $bcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %bparams = %params;
			$bparams{cache} = $bcache;
			$bparams{mech} = $bmech;
			push @plist, billiongraves => [ \&billiongraves, \%bparams ];
		}

		$entry = $gcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %gparams = %params;
			$gparams{cache} = $gcache;
			$gparams{cache2} = $gcache2;
			$gparams{cache3} = $gcache3;
			$gparams{mech} = $gmech;
			push @plist, gravestonephotos => [ \&gravestonephotos, \%gparams ];
		}

		$entry = $tf2cache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %tparams = %params;
			$tparams{cache} = $tf2cache;
			$tparams{cache2} = $tf2cache2;
			$tparams{mech} = $tf2mech;
			push @plist, teafor2 => [ \&teafor2, \%tparams ];
		}

		$entry = $vcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %vparams = %params;
			$vparams{cache} = $vcache;
			$vparams{mech} = $vmech;
			$vparams{jar} = $vjar;
			push @plist, virtualcemetery => [ \&virtualcemetery, \%vparams ];
		}

		$entry = $ccache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %cparams = %params;
			$cparams{cache} = $ccache;
			$cparams{mech} = $cmech;
			push @plist, cwgc => [ \&cwgc, \%cparams ];
		}

		$entry = $freeregcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %fparams = %params;
			$fparams{cache} = $freeregcache;
			$fparams{mech} = $freeregmech;
			push @plist, freereg => [ \&freereg, \%fparams ];
		}

		# $entry = $rcache->get($str);
		# if((!defined($entry)) || ($entry > 0)) {
			# my %rparams = %params;
			# $rparams{cache} = $rcache;
			# $rparams{mech} = $rmech;
			# push @plist, restingspot => [ \&restingspot, \%rparams ];
		# }

		# prun(@plist) || warn("$str: ", Parallel::Simple::errplus());
		unless(prun(@plist)) {
			if($debug) {
				die colored("$str: " . Parallel::Simple::errplus(), 'red');
			} else {
				warn colored("$str: " . Parallel::Simple::errplus(), 'red');
				if(Parallel::Simple::rv->{findagrave}) {
					print "Resetting Find a Grave\n" if($verbose);
					$fmech = WWW::Mechanize::GZip->new();
				}
			}
		}
		# sleep(2);
	} else {
		# Parallel::Simple fails on Windows with
		#	Attempt to free non-existent shared string
		if((!defined($dcountry)) || ($dcountry eq 'United States')) {
			$entry = $tcache->get($str);
			if((!defined($entry)) || ($entry > 0)) {
				my %tparams = %params;
				$tparams{cache} = $tcache;
				$tparams{mech} = $tmech;
				tombfinder(\%tparams);
			}
		} elsif(defined($dcountry) && ($dcountry eq 'Canada')) {
			$entry = $hcache->get($str);
			if((!defined($entry)) || ($entry > 0)) {
				my %cparams = %params;
				$cparams{cache} = $hcache;
				$cparams{cache2} = $hcache2;
				$cparams{mech} = $hmech;
				canadianheadstones(\%cparams);
			}
		}

		# Cybersquatted
		# if(defined($dcountry) && ($dcountry eq 'United States')) {
			# $entry = $hcache->get($str);
			# if((!defined($entry)) || ($entry > 0)) {
				# my %hparams = %params;
				# $hparams{cache} = $hcache;
				# $hparams{cache2} = $hcache2;
				# $hparams{mech} = $hmech;
				# americanheadstones(\%hparams);
			# }
		# }

		$entry = $fcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %fparams = %params;
			$fparams{cache} = $fcache;
			$fparams{mech} = $fmech;
			findagrave(\%fparams);
		}

		$entry = $bcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %bparams = %params;
			$bparams{cache} = $bcache;
			$bparams{mech} = $bmech;
			billiongraves(\%bparams);
		}

		$entry = $gcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %gparams = %params;
			$gparams{cache} = $gcache;
			$gparams{cache2} = $gcache2;
			$gparams{cache3} = $gcache3;
			$gparams{mech} = $gmech;
			gravestonephotos(\%gparams);
		}

		$entry = $tf2cache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %tparams = %params;
			$tparams{cache} = $tf2cache;
			$tparams{cache2} = $tf2cache2;
			$tparams{mech} = $tf2mech;
			teafor2(\%tparams);
		}

		$entry = $vcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %vparams = %params;
			$vparams{cache} = $vcache;
			$vparams{mech} = $vmech;
			$vparams{jar} = $vjar;
			virtualcemetery(\%vparams);
		}

		$entry = $ccache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %cparams = %params;
			$cparams{cache} = $ccache;
			$cparams{mech} = $cmech;
			cwgc(\%cparams);
		}

		$entry = $freeregcache->get($str);
		if((!defined($entry)) || ($entry > 0)) {
			my %fparams = %params;
			$fparams{cache} = $freeregcache;
			$fparams{mech} = $freeregmech;
			freereg(\%fparams);
		}

		# $entry = $rcache->get($str);
		# if((!defined($entry)) || ($entry > 0)) {
			# my %rparams = %params;
			# $rparams{cache} = $rcache;
			# $rparams{mech} = $rmech;
			# restingspot(\%rparams);
		# }
	}
}

sub findagrave {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $dcsp = $$params{dcsp};
	my $firstname = $$params{firstname};
	my $middlename = $$params{middlename};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);
	my $m = $$params{mech};

	my $r;

	unless($m->back()) {
		# HTTP::Response object
		$r = $m->get('http://www.findagrave.com/cgi-bin/fg.cgi');
		unless($r->is_success) {
			die 'findagrave: ', stringify($params), ': ', $r->status_line;
		}
	}

	my %fields = (
		GSfn => $firstname,
		GSln => $lastname,
		GSiman => 0,
		GSpartial => 0,
	);

	if($dod) {
		$fields{GSdy} = $dod;
		$fields{GSdyrel} = 'in';
	} elsif($dob) {
		$fields{GSby} = $dob;
		$fields{GSbyrel} = 'in';
	}

	if($middlename) {
		$fields{GSmn} = $middlename;
	}

	# Don't enable this.  If we know the date of birth but findagrave
	# doesn't, findagrave will miss the match. Of course, the downside
	# of not doing this is that you will get false positives.  It's really
	# a problem with findagrave.
	# if($dob) {
		# $fields{GSby} = $dob;
		# $fields{GSbyrel} = 'in';
	# }

	if($dcountry) {
		if($dcountry eq 'United States') {
			$fields{GScntry} = 'The United States';
			if($dcsp) {
				$fields{GSst} = $dcsp;
			}
		} else {
			$fields{GScntry} = $dcountry;
		}
	}

	$r = $m->submit_form(
		form_number => 1,
		fields => \%fields,
	);
	unless($r->is_success) {
		die 'findagrave: ', stringify($params), ': ', $r->status_line;
	}
	if($r->content =~ /Sorry, there are no records in the Find A Grave database matching your query\./) {
		$cache->set($str, 0);
		return;
	}
	my $matches;
	if($r->content =~ /<B>(\d+)<\/B>\s+total matches/mi) {
		$matches = $1;
		$cache->set($str, $matches);
		return if($matches == 0);

		unless($excel) {
			print "$str: checking $matches possible match";
			if($matches > 1) {
				print 'es';
			}
			print " on findagrave\n";
		}
	} else {
		# This seems to happen quite often, so it's a warning not
		# a die. I think it's a problem with findagrave.
		# It would be nice, at this time, to be able to clear the
		# mech object's history, but I don't think that's possible
		# my $url = $r->base();
		# warn "findagrave: $str ($url): parsing error - update the driver";
		# Perhaps it should retry?
		return;
	}

	# Shows 40 per page
	my $base = $r->base();
	my $index = 1;
	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $count = 0;

	while(1) {
		my $e = HTML::SimpleLinkExtor->new($base);
		$e->remove_tags('img', 'script');
		$e->parse($r->content);

		foreach my $link ($e->links) {
			my $match = 0;
			if($dod) {
				if($link =~ /www.findagrave.com\/cgi-bin\/fg.cgi\?.*&GSln=\Q$lastname\E.*&GSfn=\Q$firstname\E.*&GSdy=\Q$dod\E.*&GRid=\d+/i) {
					$match = 1;
				}
			} elsif(defined($dob)) {
				if($link =~ /www.findagrave.com\/cgi-bin\/fg.cgi\?.*&GSln=\Q$lastname\E.*&GSfn=\Q$firstname\E.*&GSby=\Q$dob\E.*&GRid=\d+/i) {
					$match = 1;
				}
			}
			if($match && $dcsp) {
				if($r->content !~ /\Q$dcsp\E/i) {
					$match = 0;
				}
			}
			if($match) {
				if($excel) {
					print "$str,\"$link\"\n";
				} else {
					print colored($link, 'green'), "\n";
				}
				$count++;
			}
		}
		$index += 40;
		last if($index > $matches);

		# warn "$base&sr=$index";
		my $r = $ua->get("$base&sr=$index");
		last unless($r->is_success);
	}
	$cache->set($str, $count);
}

# Doesn't work.  Billiongraves used to work really well, but they've broken it
# recently. I suspect it's another site using JavaScript jiggery pokery, and
# that's the problem
sub billiongraves {
	return;

	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $firstname = $$params{firstname};
	# my $middlename = $$params{middlename};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);

	my $url = 'http://billiongraves.com/pages/search/#';
	if($firstname) {
		$url .= "given_names=$firstname";
		# if($middlename) {
			# $url .= "+$middlename";
		# }
		$url .= '&';
	}

	$url .= "family_names=$lastname";

	if($dod) {
		$url .= "&birth_year=&death_year=$dod";
	} elsif($dob) {
		$url .= "&birth_year=$dob&death_year=";
	}

	$url .= '&year_range=5&lim=0&num=10&action=search&exact=true&phonetic=false&record_type=0';

	if($dcountry) {
		my $d = $dcountry;
		$d =~ s/\s/+/g;
		if($d =~ /England|Scotland|Wales|Northern Ireland|United kingdom|Eng/i) {
			$d = 'United+Kingdom';
		}
		$url .= "&country=$d";
		my $dcsp = $$params{dcsp};
		if(($dcountry eq 'United States') && $dcsp) {
			$dcsp = ucfirst(lc(us_state($dcsp)));
			$dcsp =~ s/\s/+/g;
			$url .= "&state=$dcsp&county=";
		} else {
			$url .= "&state=&county=";
		}
	} else {
		$url .= "country=&state=&county=";
	}

	# print "Billiongraves, checking $url\n";

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 20,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 20,
		);
	}

	$ua->env_proxy(1);

	my $r = $ua->get($url);

	unless($r->is_success) {
		warn "billiongraves: $str ($url): ", $r->status_line, "\n";
		return;
	}

	if($r->content =~ /Search Returned 0 Results\. Sorry\./) {
		$cache->set($str, 0);
		return;
	}
	if($r->content !~ /Showing.*results for/) {
		print $r->content;
		die "billiongraves: $url: parsing error - update the driver";
	}

	print "$str: found some possible matches on billiongraves\n";

	my $e = HTML::SimpleLinkExtor->new($r->base);
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($r->content));

	my $count = 0;
	foreach my $link ($e->links) {
		print "$link\n";
		if($link =~ /www.billiongraves.com\/pages\/record\/.+\Q$lastname\E/i) {
			print "\t$link\n";
			$count++;
		}
	}
	$cache->set($str, $count);
}

sub canadianheadstones {
	my $params = shift;

	my $dcsp = $$params{dcsp};

	return unless(defined($dcsp));

	my $m = $$params{mech};
	my $lastname = $$params{lastname};
	my $firstname = $$params{firstname};
	my $cache = $$params{cache};
	my $cache2 = $$params{cache2};
	my $str = stringify($params);

	$dcsp = lc(ca_2letter($dcsp));
	$dcsp =~ s/ //g;

	my $content = $cache2->get($lastname);

	unless($content) {
		my $r;

		# HTTP::Response object
		my $url = 'http://www.canadianheadstones.com/' . lc($dcsp) . "/search.php/search=custom&cfield=last&ctype=ctns&ctxt=$lastname";
		if(defined($firstname)) {
			$url .= "&cfield2=first&ctype2=ctns&ctxt2=$firstname";
		}
		unless($excel) {
			print "canadianheadstones = checking $url\n";
		}
		$r = $m->get($url);
		unless($r->is_success) {
			# Happens when looking for a province that isn't
			# correct, often from the default_subscountry setting
			warn colored("$str: $url: " . $r->status_line, 'red');
			return;
		}

		$content = $r->content;
		$cache2->set($lastname, $content);
		if($content =~ /Sorry no entries matching your search were found\./mi) {
			$cache->set($str, 0);
			return;
		}
	}

	unless($excel) {
		print "$str: found some possible matches on canadianheadstones\n";
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($content));

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $uname = uc($lastname);
	my $count = 0;
	foreach my $link ($e->links) {
		if($link =~ /\Q$dcsp\E\/view.php/i) {
			unless($link =~ /canadianheadstones\.com/) {
				$link = "http://www.canadianheadstones.com$link";
			}
			# print "canadianheadstones: $link";
			# Canadianheadstones doesn't return exact matches, let's look
			# at the record itself - the title contains something
			# we can then match against
			my $r = $ua->get($link);
			if($r->is_success) {
				my $t = $r->title();
				# print "\tChecking $t\n";
				if(defined($t) && ($t =~ /\Q$uname\E[\s,]/i)) {
					if($excel) {
						print "$str,\"$link\"\n";
					} else {
						print "\t$link\n";
					}
					$count++;
				}
			}
		}
	}
	$cache->set($str, $count);
}

sub americanheadstones {
	my $params = shift;

	my $dcsp = $$params{dcsp};

	return unless(defined($dcsp));

	my $m = $$params{mech};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);

	$dcsp = lc(us_state($dcsp));
	$dcsp =~ s/ //g;

	# HTTP::Response object
	my $url = "http://www.${dcsp}gravestones.org/search.php";
	# print "Checking $url\n";

	my $r = $m->get($url);
	unless($r->is_success) {
		# warn "$url: ", $r->status_line, "\n";
		$cache->set($str, 0);
		return;	# No site, not all states are done
	}

	my %fields = (
		last => $lastname,
	);

	if($firstname) {
		$fields{first} = $firstname;
	}

	eval {
		$r = $m->submit_form(
			form_number => 1,
			fields => \%fields,
		);
	};
	if($@) {
		warn "$url: $@";
		$cache->set($str, 0);
		return;
	}
	unless($r->is_success) {
		warn "$url: ", $r->status_line, "\n";
		return;
	}

	if($r->content =~ /Sorry no entries matching your search were found\./mi) {
		$cache->set($str, 0);
		return;
	}

	print "$str: found some possible matches on ${dcsp}gravestones.org\n";

	my $e = HTML::SimpleLinkExtor->new($r->base);
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($r->content));

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $uname = uc($lastname);
	my $count = 0;
	my $cache2 = $$params{cache2};
	foreach my $link ($e->links) {
		if($link =~ /\/view.php\?id=(\d+)/) {
			my $id = $1;
			# Canadianheadstones doesn't return exact matches,
			# let's look at the record itself - the title contains
			# something we can then match against
			unless($link =~ /gravestones\.org/) {
				$link = "http://www.${dcsp}gravestones.org$link";
			}
			# Because you search on so little on this site you
			# often find the same record, so cache it
			my $t = $cache2->get($id);
			unless($t) {
				$r = $ua->get($link);
				if($r->is_success) {
					$t = $r->title();
					if($t) {
						$cache2->set($id, $t);
					}
				}
			}
			if($t) {
				# print "$link: Checking $t\n";
				if(defined($t) && ($t =~ /\Q$uname\E[\s,]/i)) {
					print "\t$link\n";
					$count++;
				}
			}
		}
	}
	$cache->set($str, $count);
}

# US only
sub tombfinder {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);
	my $m = $$params{mech};
	my $dcountry = $$params{dcountry};
	my $dcsp = $$params{dcsp};

	my $r;
	unless($m->back()) {
		# HTTP::Response object
		$r = $m->get('http://www.tombfinder.com/records');
		unless($r->is_success) {
			warn 'tombfinder: ', $r->status_line, "\n";
			return;
		}
	}

	my %fields = (
		'search[first_name_contains]' => $firstname,
		'search[surname_contains]' => $lastname,
	);

	if($dod) {
		$fields{'search[death_year_less_than_or_equal_to]'} = $dod;
	} elsif($dob) {
		$fields{'search[birth_year_greater_than_or_equal_to]'} = $dob;
	}

	if($dcsp && ($dcountry eq 'United States')) {
		$fields{'search_account_state_contains'} = $dcsp;
	}

	$r = $m->submit_form(
		form_number => 1,
		fields => \%fields,
	);
	unless($r->is_success) {
		warn 'tombfinder: ', stringify($params), ': ', $r->status_line, "\n";
		return;
	}

	if($r->content =~ /Your search returned (\d+) records/mi) {
		$cache->set($str, $1);
		return if($1 == 0);

		unless($excel) {
			print "$str: checking $1 possible match";
			if($1 > 1) {
				print 'es';
			}
			print " on tombfinder\n";
		}
	} else {
		$cache->set($str, 0);
		return;
	}

	my $e = HTML::SimpleLinkExtor->new($r->base);
	$e->remove_tags('img', 'script');
	$e->parse($r->content);

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $count = 0;
	foreach my $link ($e->links) {
		if($link =~ /\.tombfinder\.com\/records\/\d+/) {
			# Tombfinder doesn't return exact matches, let's look
			# at the record itself - the title contains something
			# we can then match against
			$r = $ua->get($link);
			if($r->is_success) {
				my $t = $r->title();
				# print "tombfinder: checking $t\n";
				if(defined($t) && ($t =~ /[\s,]\Q$lastname\E[\s,]/i)) {
					if($dod && ($t !~ /\Q$dod\E/)) {
						next;
					} elsif($dob && ($t !~ /\Q$dob\E/)) {
						next;
					}
					if($excel) {
						print "$str,$link\n";
					} else {
						print colored($link, 'green'), "\n";
					}
					$count++;
				}
			}
		}
	}
	$cache->set($str, $count);
}

sub gravestonephotos {
	my $params = shift;

	my $dcountry = $$params{dcountry};

	return unless defined($dcountry);

	my $dod = $$params{dod};
	my $dcsp = $$params{dcsp};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $cache2 = $$params{cache2};
	my $str = stringify($params);

	my $content = $cache2->get($lastname);

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 30,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 30,
		);
	}

	$ua->env_proxy(1);

	unless($content) {
		# print "gravestonephotos $dcountry $lastname\n";
		my $l = $lastname;
		$l =~ s/ /+/g;
		my $url = "http://www.gravestonephotos.com/public/findfamily.php?name=$l";
		# print "getting $url\n";
		my $r = $ua->get($url);
		# HTTP::Response object
		unless($r->is_success) {
			warn "$url: ", $r->status_line, "\n";
			return;
		}

		$content = $r->content;

		$cache2->set($lastname, $content);

		if(($content =~ /Sorry but there are no entries for the name \Q$lastname\E/i) ||
		   ($content =~ /Sorry but there are no entries for the name \Q$l\E/i)) {
			$cache->set($str, 0);
			return;
		}

		if($l =~ /'/) {
			# Bug in gravestones.com, which has been reported
			$l =~ s/'/\\'/g;
		}

		if(($content !~ /all entries within the Gravestone Photographic Resource for the name \Q$lastname\E/i) &&
		   ($content !~ /all entries within the Gravestone Photographic Resource for the name \Q$l\E/i)) {
			print $content;
			die "gravestonephotos: $str (lastname $lastname/$l): parsing error - update the driver\n";
		}
		unless($content =~ /\Q$dcountry\E/i) {
			$cache->set($str, 0);
			return;
		}
		if($dod) {
			unless($content =~ /\Q$dod\E/) {
				$cache->set($str, 0);
				return;
			}
		}
		if($firstname) {
			unless($content =~ /\Q$firstname\E/) {
				$cache->set($str, 0);
				return;
			}
		}
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($content));

	my $dob = $$params{dob};

	my $cache3 = $$params{cache3};
	my $count = 0;
	foreach my $link ($e->links) {

	# # http://stackoverflow.com/questions/254345/how-can-i-extract-url-and-link-text-from-html-in-perl
	# # Don't do until RT77998 is fixed
	# my $doc;
	# eval {
		# $doc = XML::LibXML->load_html(string => $content, recover => 2);
	# };
	# if($@) {
		# warn "gravestonephotos: error parsing $str";
		# $cache->set($str, 0);
		# return;
	# }
	# my %links;
	# foreach my $anchor ($doc->findnodes('//a[@href]')) {
		# # printf "%15s -> %s\n",
			# # $anchor->textContent,
			# # $anchor->getAttribute('href');

		# $links{$anchor->textContent} = $anchor->getAttribute('href');
	# }

	# foreach my $link (keys(%links)) {
		# next unless($link =~ /\Q$lastname\E/i);

		# if($firstname) {
			# next unless($link =~ /\Q$firstname\E/i);
		# }
		# $link = $links{$link};
		if($link =~ /gravedetails.php\?.*fullname=\Q$firstname\E\s\Q$lastname\E/i) {
			$link =~ s/ /%20/g;
			$link = "http://www.gravestonephotos.com/public/$link";
			# Gravestonephotos doesn't return exact matches, let's
			# look at the record itself - the title contains
			# something we can then match against

			my $t = $cache3->get("$link/title");
			unless($t) {
				my $r = $ua->get($link);
				if($r->is_success()) {
					$t = $r->title();
					$cache3->set("$link/title", $t);
					if($t) {
						$cache3->set("$link/content", $r->content());
					}
				}
			}
			next unless defined($t);

			my $match = 0;
			# print "gravestonephotos $str: comparing $t\n";
			if(defined($firstname)) {
				if(defined($dcsp)) {
					if($t =~ /\Q$dcsp\E.*\Q$dcountry\E.*\Q$firstname\E.*\Q$lastname\E/i) {
						$match = 1;
					}
				} else {
					if($t =~ /\Q$dcountry\E.*\Q$firstname\E.*\Q$lastname\E/i) {
						$match = 1;
					}
				}
			} else {
				if(defined($dcsp)) {
					if($t =~ /\Q$dcsp\E.*\Q$dcountry\E.*\Q$lastname\E/i) {
						$match = 1;
					}
				} else {
					if($t =~ /\Q$dcountry\E.*\Q$lastname\E/i) {
						$match = 1;
					}
				}
			}
			if($match) {
				my $content;

				if($dod || $dob) {
					$content = $cache3->get("$link/content");
				}
				if($dod) {
					if($content !~ /\Q$dod\E/) {
						$match = 0;
					}
				} elsif($dob) {
					if($content !~ /\Q$dob\E/) {
						$match = 0;
					}
				}
				if($match) {
					print "$str: found $t on gravestonephotos.com\n",
						"\t$link\n";
					$count++;
				}
			}
			# print 'x' x 40, "\n";
		}
	}
	$cache->set($str, $count);
}

sub teafor2 {
	my $params = shift;

	my $dcountry = $$params{dcountry};
	return unless defined($dcountry);

	my $cache = $$params{cache};
	my $cache2 = $$params{cache2};
	my $content = $cache2->get('http://teafor2.com/AW/index.php');
	my $lastname = $$params{lastname};
	my $str = stringify($params);

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 30,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 30,
		);
	}

	$ua->env_proxy(1);

	unless($content) {
		my $r = $ua->get('http://teafor2.com/AW/index.php');
		# HTTP::Response object
		unless($r->is_success) {
			warn "teafor2: ", $r->status_line, "\n";
			return;
		}

		$content = $r->content;

		$cache2->set('index', $content);
	}

	my $dcsp = $$params{dcsp};
	if($dcountry eq 'United States') {
		unless(defined($dcsp)) {
			$cache->set($str, 0);
			return;
		}

		$dcountry = 'USA';

	} elsif($dcountry eq 'England') {
		$dcountry = 'ENG';
	}

	my $count = 0;
	if(defined($dcsp)) {
		while($content =~ /<h4>.+?\Q$dcsp\E.+?\Q$dcountry\E.+?<\/h4>.+<a href="(.+?)">/g) {
			warn "TODO: teafor2 $lastname: $dcsp $dcountry $1\n";
			$count++;
		}
	} else {
		while($content =~ /<h4>.+?\Q$dcountry\E.+?<\/h4>.+<a href="(.+?)">/g) {
			warn "TODO: teafor2 $lastname: $dcountry $1\n";
			$count++;
		}
	}
	$cache->set($str, $count);
}

sub virtualcemetery {
	return;
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $dcsp = $$params{dcsp};
	my $firstname = $$params{firstname};
	my $middlename = $$params{middlename};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);
	my $m = $$params{mech};

	my $r;
	unless($m->back()) {
		# HTTP::Response object
		$r = $m->get('http://www.genealogy.com/VG/vcem_search.html');
		unless($r->is_success) {
			warn colored('virtualcemetery: ' . $r->status_line, 'red');
			return;
		}
		if($r->content =~ /To better assist your research we will redirect you/) {
			# print $r->content;
			die "Failed to set the cookie corectly on genealogy.com";
		}
	}

	my %fields = (
		FIRSTNAME => $firstname,
		LASTNAME => $lastname,
	);

	if($dod) {
		$fields{ddyear} = $dod;
	} elsif($dob) {
		$fields{bdyear} = $dob;
	}

	if($middlename) {
		$fields{MIDDLENAME} = $middlename;
	}

	# Don't enable this.  If we know the date of birth but findagrave
	# doesn't, findagrave will miss the match. Of course, the downside
	# of not foing this is that you will get false positives.  It's really
	# a problem with findagrave.
	# if($dob) {
		# $fields{GSby} = $dob;
		# $fields{GSbyrel} = 'in';
	# }

	if($dcountry) {
		if($dcountry eq 'United States') {
			$fields{DPCOUNTRY} = 'USA';
			if($dcsp) {
				$fields{DPSTATE} = us_2letter($dcsp);
				# print "virtual cemetery: state = $fields{DPSTATE}\n";
			}
		} else {
			$fields{DPCOUNTRY} = $dcountry;
			if($dcsp) {
				$fields{DPSTATE} = $dcsp;
			}
		}
	}

	$r = $m->submit_form(
		form_number => 2,
		fields => \%fields,
	);
	unless($r->is_success) {
		warn colored('virtualcemetery: ' . $r->status_line, 'red');
		return;
	}
	if($r->content =~ /No matches/) {
		$cache->set($str, 0);
		return;
	}

	unless($excel) {
		print "$str: found some possible matches on virtual cemetery\n";
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse($r->content);

	if(scalar($e->links) == 0) {
		# No links seems unlikely, there must be something wrong
		die "virtualcemetery: $str: parsing error - update the driver\n";
	}

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
			cookie_jar => $$params{jar},
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
			cookie_jar => $$params{jar},
		);
	}

	$ua->env_proxy(1);

	my $count = 0;
	foreach my $link ($e->links) {
		if($link =~ /VG\/.+\/index.html/) {
			unless($link =~ /genealogy\.com/) {
				$link = "http://www.genealogy.com$link";
			}
			# print "genealogy: $link\n";
			my $r = $ua->get($link);
			my $match = 0;
			if($r->is_success) {
				$match = 1;
				my $content = $r->content();

				if(defined($dcountry) && ($content !~ /\Q$dcountry\E/i)) {
					$match = 0;
				} elsif(defined($dcsp) && ($content !~ /\Q$dcsp\E/i)) {
					$match = 0;
				}
				if($match) {
					if($dod) {
						if($r->content() !~ /\Q$dod\E/) {
							$match = 0;
						}
					} elsif($dob) {
						if($r->content() !~ /\Q$dob\E/) {
							$match = 0;
						}
					}
				}
			}
			if($match) {
				if($excel) {
					print "$str,$link\n";
				} elsif($^O eq 'MSWin32') {
					print "\t$link\n";
				} else {
					print colored($link, 'green'), "\n";
				}
				$count++;
			}
		}
	}
	$cache->set($str, $count);
}

# Commonwealth War Graves Commission - covers graves of First and Second World Wars and possibly
# later
# Doesn't seem to work, most likely because of the bizarre JavaScript way that the site uses
sub cwgc {
	my $params = shift;

	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $m = $$params{mech};
	my $cache = $$params{cache};
	my $str = stringify($params);

	return unless(defined($dod));

	my $dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
	my $year = $dfn->parse_datetime($dod)->year();
	if(($year < 1914) || ($year > 1945)) {
		return;
	}
	unless(($year <= 1918) || ($year >= 1939)) {
		return;
	}

	# print colored("Checking $str (died $year) on CWGC", 'red'), "\n";

	# if(defined($dob)) {
		# $dt = $dfn->parse_datetime($dob);
		# # Assume not in CWGC if born before 1850
		# if($dt->year() < 1850) {
			# return;
		# }
		# # Assume not a war dead if born less than 16 years ago

		# my $daysold = Date::Calc::Delta_Days($dt->year(), $dt->month(), $dt->day(), Date::Calc::Today());
		# if($daysold < 5844) {
			# return;
		# }
	# }

	my $r;
	unless($m->back()) {
		# HTTP::Response object
		$r = $m->get('http://www.cwgc.org/find-war-dead.aspx');
		unless($r->is_success) {
			warn 'cwgc: ', $r->status_line, "\n";
			return;
		}
	}

	my %fields = (
		Surname => $lastname,
	);

	if($firstname) {
		$m->set_visible([ radio => 'Forename' ]);
		$fields{Forename} = $firstname;
	}
	$r = $m->submit_form(
		form_number => 1,
		fields => \%fields,
	);
	unless($r->is_success) {
		warn "cwgc: $str: ", $r->status_line, "\n";
		return;
	}
	if($r->content =~ /No results found/mi) {
		$cache->set($str, 0);
		return;
	}
	if($r->content =~ /(\d+)records\(s\) march your search criteria/mi) {
		my $matches = $1;
		$cache->set($str, $matches);
		return if($matches == 0);

		print "$str: checking $matches possible match";
		if($matches > 1) {
			print 'es';
		}
		print " on CWGC\n";
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse($r->content);

	if(scalar($e->links) == 0) {
		# No links seems unlikely, there must be something wrong
		die "cwgc: $str: parsing error - update the driver\n";
	}

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $count = 0;
	my $uc = uc($lastname);
	my $dcsp = $$params{dcsp};

	foreach my $link ($e->links) {
		if($link =~ /find-war-dead\/casualty\/.+\/\Q$uc/) {
			# print colored("Checking $link", 'red'), "\n";
			my $r = $ua->get($link);
			my $match = 0;
			if($r->is_success) {
				$match = 1;
				my $content = $r->content();

				if(defined($dcountry) && ($content !~ /\Q$dcountry\E/i)) {
					$match = 0;
				} elsif(defined($dcsp) && ($content !~ /\Q$dcsp\E/i)) {
					$match = 0;
				}
				if($match) {
					if($dod) {
						if($r->content() !~ /\Q$dod\E/) {
							$match = 0;
						}
					}
				}
			}
			if($match) {
				print colored($link, 'green'), "\n";
				$count++;
			}
		}
	}
	$cache->set($str, $count);
}

sub freereg {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $dcsp = $$params{dcsp};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);
	my $m = $$params{mech};

	unless(defined($dcountry) && ($dcountry =~ /England|Scotland|Wales|Northern Ireland|United kingdom|Eng/i)) {
		return;
	}
	unless($dcsp) {
		return;
	}

	my $r;
	unless($m->back()) {
		# HTTP::Response object
		# $r = $m->get('http://www.freereg.org.uk/cgi/Search.pl');
		$r = $m->get('http://freereg1.freereg.org.uk/cgi/Search.pl');
		unless($r->is_success) {
			warn colored('freereg: ' . $r->status_line . "\n", 'red');
			return;
		}
	}

	state $gb ||= Locale::SubCountry->new('gb');

	my %fields = (
		Surname => $lastname,
		Forename => $firstname,
		Year => $dod,
		YearRange => 0,
		Soundex => 'OFF', # Yes - FreeREG's Soundex has too many false positives
		RecordType => 'Burials',
		Action => 'Search',
	);

	$m->form_number(2);
	$m->select('County', $dcsp);
	if($dcsp =~ /Sussex/i) {
		$m->select('County', 'SSX');
	} elsif($dcsp =~ /London|Middlesex/i) {
		$m->select('County', 'MDX');
	} else {
		$m->select('County', $gb->code($dcsp));
	}
	$m->select('Place', 'All');
	$m->set_fields(%fields);
	$r = $m->click();

	unless($r->is_success) {
		warn "freereg: $str: ", $r->status_line, "\n";
		return;
	}
	if($r->content =~ /Error/) {
		if($r->content =~ /Unknown county/) {
			warn colored("freereg: $str: Unknown county $dcsp", 'red');
			$cache->set($str, 0);
			return;
		}
		die "freereg: $str: parsing error, Error found in content - update the driver\n";
	}
	if($r->content =~ /0 matches were found for this query/) {
		$cache->set($str, 0);
		return;
	}
	unless($excel) {
		print "$str: checking possible match in FreeREG\n";
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($r->content));

	if(scalar($e->links) == 0) {
		# No links seems unlikely, there must be something wrong
		die "freereg: $str: parsing error, no links found - update the driver\n";
	}

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
		);
	}

	$ua->env_proxy(1);

	my $count = 0;
	my $comment = '';
	my $print_string = $str;
	foreach my $link ($e->links) {
		unless($link =~ /SearchResults\.pl/) {
			next;
		}

		# my $url = "http://www.freereg.org.uk/cgi/$link";
		my $url = "http://freereg1.freereg.org.uk/cgi/$link";

		my $r = $ua->get($url);
		unless($r->is_success) {
			warn colored("freereg ($url): " . stringify($params) . ': ' . $r->status_line, 'red');
			if($r->status_line eq '500 read timeout') {
				# TODO: clear WWW::Mechanize::GZip cache and try again
				next;
			}
			return;
		}
		my $content = $r->content();

		if($dob || $dod) {
			if($content =~ /Search session timed out/) {
				# This is pretty annoying...
				# TODO: clear WWW::Mechanize::GZip cache and try again
				next;
			}
			if($content =~ /BurialDate<\/TD><TD>(.*?)<\/TD>/) {
				my $burial_year = $1;
				if($burial_year && ($burial_year =~ /.*?(\d{3,4})/)) {
					$burial_year = $1;
				}

				if($content =~ /Age<\/TD><TD>(\d+?)<\/TD>/) {
					my $age = $1;
					if($dod && !defined($dob)) {
						# Estimate date of birth to reduce false positives
						$dob = $dod - $age;
					} elsif($dob) {
						# print "freereg: $dob; $age; $burial_year\n" if($verbose);
						if((($dob + $age) > ($burial_year + 2))) {
							next;
						}
						if((($dob + $age) < ($burial_year - 2))) {
							next;
						}
					}
				}

				my $dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
				my $year = $dfn->parse_datetime($burial_year)->year();
				if($dod) {
					if($year > $dod + 2) {
						# This record is of someone buried way after
						# current person died, so it can't be a match
						next;
					}
				}
				if($dob) {
					if($year < $dob) {
						# This record is of someone buried before the
						# current person was born, so it can't be a match
						next;
					}
					if($year > $dob + 100) {
						# This record is of someone buried way after
						# current person was born, so it can't be a match
						next;
					}
				}
				if($content =~ /Place<\/TD><TD>(.*?)<\/TD>/) {
					# Print this out because the search
					# is based by county and we can
					# use the place to decide which URLs
					# to not investigate further.
					$comment = "Place of death: $1: ";
				} else {
					print colored("$url: Couldn't extract the place of death", 'yellow'), "\n";
				}
				$comment .= "Date of burial: $burial_year ";
				unless($excel) {
					print $comment;
				}
			} else {
				die "freereg ($url): $str: parsing error - update the driver\n";
			}
		} elsif($content =~ /Place<\/TD><TD>(.*?)<\/TD>/) {
			# Print this out because the search
			# is based by county and we can
			# use the place to decide which URLs
			# to not investigate further.
			if($excel) {
				$comment = $1;
			} else {
				print "Place of death: $1 ";
			}
		} else {
			print colored("$url: Couldn't extract the place of death", 'yellow'), "\n";
		}

		if($excel) {
			print "$print_string,$url,$comment\n";
			$print_string = '""';
		} else {
			print colored($url, 'green'), "\n";
		}
		$count++;
	}
	$cache->set($str, $count);
}

sub restingspot {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $dcountry = $$params{dcountry};
	my $dcsp = $$params{dcsp};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $cache = $$params{cache};
	my $str = stringify($params);
	my $m = $$params{mech};

	my $r;
	unless($m->back()) {
		# HTTP::Response object
		$r = $m->get('http://www.restingspot.com');
		unless($r->is_success) {
			warn 'restingspot: ', $r->status_line, "\n";
			return;
		}
	}

	my %fields = (
		searchval => ($firstname) ? "$firstname $lastname" : $lastname
	);

	$r = $m->submit_form(
		form_number => 1,
		fields => \%fields,
	);
	unless($r->is_success) {
		warn 'restingspot: ', stringify($params), ': ', $r->status_line, "\n";
		return;
	}
	if($r->content =~ /No Resting Spot Added/) {
		$cache->set($str, 0);
		return;
	}

	if($r->content =~ /RestingSpots (\d+)/) {
		print "$str: found $1 possible matches on resting spot\n";
	}

	my $e = HTML::SimpleLinkExtor->new();
	$e->remove_tags('img', 'script');
	$e->parse(Encode::decode_utf8($r->content));

	if(scalar($e->links) == 0) {
		# No links seems unlikely, there must be something wrong
		die "restingspots: $str: parsing error - update the driver\n";
	}

	state $ua;
	if($parallel) {
		$ua ||= LWPx::UserAgent::Cached->new(
			cache => $lwpcache,
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
			cookie_jar => $$params{jar},
		);
	} else {
		$ua ||= LWP::UserAgent->new(
			keep_alive => 1,
			agent => 'gedgrave',
			from => 'njh@despammed.com',
			timeout => 10,
			cookie_jar => $$params{jar},
		);
	}

	$ua->env_proxy(1);

	my $count = 0;
	foreach my $link ($e->links) {
		if($link =~ /\/search\/cemetery\//) {
			last;
		}
		unless($link =~ /\/\Q$lastname\E\//i) {
			next;
		}
		unless($link =~ /restingspot\.com/) {
			$link = "http://www.restingspot.com$link";
		}
		# print "restingspot: $link\n";
		my $r = $ua->get($link);
		my $match = 0;
		if($r->is_success) {
			$match = 1;
			my $content = $r->content();

			if(defined($dcountry) && ($content !~ /\Q$dcountry\E/i)) {
				$match = 0;
			} elsif(defined($dcsp) && ($content !~ /\Q$dcsp\E/i)) {
				$match = 0;
			}
			if($match) {
				if($dod) {
					if($r->content() !~ /\Q$dod\E/) {
						$match = 0;
					}
				} elsif($dob) {
					if($r->content() !~ /\Q$dob\E/) {
						$match = 0;
					}
				}
			}
		}
		if($match) {
			print "\t$link\n";
			$count++;
		}
	}
	$cache->set($str, $count);
}

# Pretty print a person
sub stringify {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $middlename = $$params{middlename};
	my $maidenname = $$params{maidenname};
	my $suffix = $$params{suffix};

	my $rc = ucfirst($lastname);

	if($firstname) {
		my $f = ucfirst($firstname);
		$rc .= ", $f";
		if($middlename) {
			$f = ucfirst($middlename);
			$rc .= " $f";
		}
	}

	if($maidenname && ($maidenname ne $lastname)) {
		foreach(split / /, $maidenname) {
			if($_ ne $lastname) {
				my $m .= ucfirst($_);
				$rc .= " (nee $m)";
				last;
			}
		}
	}

	if($suffix) {
		$rc .= " $suffix";
	}

	$rc .= ' ';

	if($dob) {
		$rc .= $dob;
	}

	$rc .= '-';

	if($dod) {
		return "$rc$dod";
	}

	return $rc;
}

# Parse the location field and try to extract country and state of death to
# optimise the burial site look-up
sub check_country {
	my $args = shift;

	my $country = $$args{country};

	if($country =~ /\d/) {
		print colored("Found a country ($country) with a digit in it", 'yellow'), "\n";
		return undef, undef;
	}
	my $csp = $$args{csp};

	if((!defined($country)) && defined($csp)) {
		$country = $csp;
		$csp = undef;
	}

	if(defined($csp)) {
		if($csp eq 'Northampton') {
			return 'England', 'Northamptonshire';
		}
		if($csp =~ /^Newcastle Upon/i) {
			return 'England', undef;
		}
	}

	if($country eq 'UK') {
		return 'England', $csp;
	}

	if(($country =~ /England/) ||
	   ($country eq 'Wales') ||
	   ($country eq 'Scotland')) {
		return $country, $csp;
	}

	if(($country eq 'Kent') ||
	   ($country =~ /Sussex$/) ||
	   ($country eq 'Essex') ||
	   ($country eq 'Surrey') ||
	   ($country eq 'London') ||
	   ($country eq 'Berkshire') ||
	   ($country =~ /Yorkshire/) ||
	   ($country eq 'Norfolk') ||
	   ($country eq 'Lancashire') ||
	   ($country eq 'Suffolk') ||
	   ($country eq 'Middlesex') ||
	   ($country eq 'Gloucestershire') ||
	   ($country eq 'Hertfordshire') ||
	   ($country eq 'Derbyshire') ||
	   ($country =~ /Durham$/) ||
	   ($country eq 'Dorset') ||
	   ($country eq 'Shropshire') ||
	   ($country eq 'Devon') ||
	   ($country eq 'Cornwall') ||
	   ($country eq 'Lincolnshire') ||
	   ($country eq 'Warwickshire') ||
	   ($country eq 'Buckinghamshire') ||
	   ($country eq 'Wiltshire') ||
	   ($country eq 'Somerset') ||
	   ($country eq 'Northumberland') ||
	   ($country eq 'Leicestershire') ||
	   ($country eq 'Cambridgeshire') ||
	   ($country eq 'Northamptonshire') ||
	   ($country =~ /Isle of Wight/i) ||
	   ($country eq 'Nottinghamshire') ||
	   ($country eq 'Merseyside') ||
	   ($country eq 'Cheshire') ||
	   ($country eq 'Staffordshire') ||
	   ($country eq 'Oxfordshire') ||
	   ($country eq 'Hampshire')) {
		return 'England', $country;
	}

	if(($country =~ /Glamorgan/) ||
	   ($country eq 'Clywd')) {
		return 'Wales', $country;
	}

	if($country eq 'NZ') {
		return 'New Zealand', undef;
	}

	$csp ||= $country;

	if($csp eq 'Northampton') {
		return 'England', 'Northamptonshire';
	}

	if(($csp eq 'Tasmania') ||
	   ($csp eq 'South Australia') ||
	   ($csp eq 'Western Australia') ||
	   ($csp =~ /NSW/)) {
		return 'Australia', $csp;
	}

	if($country =~ /France/) {
		return 'France', undef;
	}

	my $s = us_state($csp);
	if($s) {
		return 'United States', $s;
	}
	if(defined($$args{default_country}) && ($$args{default_country} =~ /United States/i)) {
		# Probably no country given and the state has therefore ended
		# in the country field
		$s = us_state($country);
		if($s) {
			return 'United States', $s;
		}
		# Handle "Foo Florida; as well as Foo, Florida"
		my $c = $country;
		if($c =~ /\s(.+)?/) {
			$s = us_state($1);
			if($s) {
				return 'United States', $s;
			}
		}
	}
	$s = us_state($country);
	if($s) {
		return 'United States', $s;
	}
	if(($country =~ /USA$/) ||
	   ($country eq 'America')) {
		return 'United States', undef;
	}

	$s = ca_province($csp);
	if($s) {
		return 'Canada', $s;
	}
	$s = ca_province($country);
	if($s) {
		return 'Canada', $s;
	}

	if(($csp eq 'Austria') && ($country eq 'Hungary')) {
		print colored('Austria-Hungary has a dash not a comma', 'yellow'), "\n";
		return 'Austria-Hungary', undef;
	}
	local $SIG{__WARN__} = sub { die $_[0] };

	eval {
		Locale::Object::Country->new(name => $country);
	};
	if($@) {
		return;
	}
	return $country, $csp;
}

# Returns the full name of the given US state
sub us_state {
	my $csp = shift;

	my $us = Locale::US->new();
	if(exists($us->{code2state}{uc($csp)})) {
		# Two letter postal abbreviation
		return $us->{code2state}{uc($csp)};
	}
	if(exists($us->{state2code}{uc($csp)})) {
		return $csp;
	}
}

# Returns the full name of the given Canadian province
sub ca_province {
	my $csp = shift;

	my $ca = Locale::US->new();
	if(exists($ca->{code2province}{uc($csp)})) {
		# Two letter postal abbreviation
		return $ca->{code2province}{uc($csp)};
	}
	if(exists($ca->{province2code}{uc($csp)})) {
		return $csp;
	}
}

# Returns the 2 letter postal code of the given US state
sub us_2letter {
	my $csp = uc(shift);

	my $us = Locale::US->new();
	if(exists($us->{code2state}{$csp})) {
		return $csp;
	}
	if(exists($us->{state2code}{$csp})) {
		# Two letter postal abbreviation
		return $us->{state2code}{$csp};
	}
}

# Returns the 2 letter postal code of the given Canadian province
sub ca_2letter {
	my $csp = uc(shift);

	my $ca = Locale::CA->new();
	if(exists($ca->{code2province}{$csp})) {
		return $csp;
	}
	if(exists($ca->{province2code}{$csp})) {
		# Two letter postal abbreviation
		return $ca->{province2code}{$csp};
	}
}
